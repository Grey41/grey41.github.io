<!DOCTYPE html>
	<head>
		<!-- Global site tag (gtag.js) - Google Analytics -->
		<script async src = "https://www.googletagmanager.com/gtag/js?id=G-W2C6ZR2P0X"></script>
		
		<script>
			window.dataLayer = window.dataLayer || [];
			function gtag() {dataLayer.push(arguments);}
			gtag('js', new Date());

			gtag('config', 'G-C34XCNZ9G4');
		</script>

		<meta charset = utf-8>
		<title>Snake</title>
	</head>

	<body>
		<canvas id = canvas></canvas>
		<script>
			class Base {
				constructor(x, y, length, color) {
					this.body = [{x, y}]
					this.length = length
					this.color = color
					this.travel = 0
				}

				grow(travel) {
					this.travel += travel

					if (this.travel > size) {
						this.body.push({x: this.head.x, y: this.head.y})
						this.travel = travel
					}
				}

				get head() {
					return this.body[this.body.length - 1]
				}
			}

			class Snake extends Base {
				constructor() {
					super(random(0, canvas.width), random(0, canvas.height), random(2, 10), green())

					this.timer = random(0, 100)
					this.direction = ['up', 'down', 'left', 'right'][random(0, 3)]
					this.state = true
					this.type = (random(0, 15)) ? 0 : 1

					let hit; for (let player of players) hit = (distance(this.head, player.head) < 100)
					if (!hit) snakes.push(this)
				}

				up() {this.direction = ['up', 'left', 'right'][random(0, 2)]; this.timer = random(0, 100)}
				left() {this.direction = ['up', 'down', 'left'][random(0, 2)]; this.timer = random(0, 100)}
				down() {this.direction = ['down', 'left', 'right'][random(0, 2)]; this.timer = random(0, 100)}
				right() {this.direction = ['up', 'down', 'right'][random(0, 2)]; this.timer = random(0, 100)}

				die() {
					this.state = false
					this.color = (this.type) ? '#fff' : '#888'
				}

				sense(part) {
					if (this.direction == 'up' &&
						this.head.y < part.y + size * 2 &&
						this.head.y > part.y &&
						part.x < this.head.x + size &&
						part.x + size > this.head.x)

						this.down()
			
					else if (this.direction == 'down' &&
						this.head.y + size * 2 > part.y &&
						this.head.y < part.y &&
						part.x < this.head.x + size &&
						part.x + size > this.head.x)
							
						this.up()
					
					else if (this.direction == 'left' &&
						this.head.x < part.x + size * 2 &&
						this.head.x > part.x &&
						part.y < this.head.y + size &&
						part.y + size > this.head.y)
							
						this.right()
		
					else if (this.direction == 'right' &&
						this.head.x + size * 2 > part.x &&
						this.head.x < part.x &&
						part.y < this.head.y + size &&
						part.y + size > this.head.y)
							
						this.left()
				}

				update() {
					if (this.state) {
						let travel = (this.type) ? speed + 2 : speed
						this.timer -= (this.type) ? 2 : 1
						this.grow(travel)

						if (this.body.length > this.length) this.body.shift()
						if (this.direction == 'up') this.head.y -= travel
						else if (this.direction == 'down') this.head.y += travel
						else if (this.direction == 'left') this.head.x -= travel
						else if (this.direction == 'right') this.head.x += travel

						/*if (!snakes.indexOf(this)) {
							console.log(travel)
							console.log(speed)
						}*/

						if (this.timer < 0) {
							let close = {snake: undefined, distance: canvas.width / 2}

							for (let snake of snakes) {
								let space = distance(this.head, snake.head)

								if (!snake.state) {
									if (close.distance == undefined || space < close.distance) {
										close.snake = snake
										close.distance = space
									}
								}
							}

							if (close.snake != undefined) {
								let x = close.snake.head.x - this.head.x, y = close.snake.head.y - this.head.y
								if (y <= -size) this.direction = 'up'
								else if (y >= size) this.direction = 'down'
								else if (x <= -size) this.direction = 'left'
								else if (x >= size) this.direction = 'right'

								this.timer = random(0, Math.round(size / speed))
							}

							else {
								this.direction = ['up', 'down', 'left', 'right'][random(0, 3)]
								this.timer = random(0, 100)
							}

							if (this.type) this.color = color()
						}

						if (this.head.x < speed) this.right()
						else if (this.head.x + size > canvas.width - speed) this.left()
						else if (this.head.y < speed) this.down()
						else if (this.head.y + size > canvas.height - speed) this.up()
					}

					context.fillStyle = this.color

					for (let part of this.body) {
						context.fillRect(part.x, part.y, size, size)

						for (let player of players) {
							if (collide(part, player.head)) {
								player.collide(this, part)
								continue
							}
						}

						for (let snake of snakes) {
							if (snakes.indexOf(this) == snakes.indexOf(snake)) continue
							if (snake.state && this.state) snake.sense(part)

							if (collide(part, snake.head)) {
								if (this.state) snake.die()
								
								else {
									snake.length += 500 / snake.length
									this.body.splice(this.body.indexOf(part), 1)
									continue
								}
							}
						}
					}

					if (!this.body.length || !this.state && (this.head.x > canvas.width || this.head.x + size < 0 || this.head.y > canvas.height || this.head.y + size < 0))
						snakes.splice(snakes.indexOf(this), 1)
				}
			}

			class Player extends Base {
				constructor(x, y, color, up, down, left, right) {
					super(eval(x), eval(y), 2, color)
					this.start = {x, y}
					this.up = up
					this.down = down
					this.left = left
					this.right = right
					players.push(this)
				}

				collide(snake, part) {
					if (snake.state) this.reset()
					else {
						snake.body.splice(snake.body.indexOf(part), 1)
						this.length += ((snake.type) ? 500 : 100) / this.length
					}
				}

				reset() {
					this.length = (this.length / 4 > 2) ? this.length / 4 : 2
					this.body = [{x: eval(this.start.x), y: eval(this.start.y)}]
				}

				update() {
					if (eval(this.up)) this.head.y -= speed, this.grow(speed)
					else if (eval(this.down)) this.head.y += speed, this.grow(speed)
					else if (eval(this.left)) this.head.x -= speed, this.grow(speed)
					else if (eval(this.right)) this.head.x += speed, this.grow(speed)

					context.fillStyle = this.color

					for (let part of this.body) {
						context.fillRect(part.x, part.y, size, size)
						if (players.length > 1 && collide(part, players[1 - players.indexOf(this)].head)) players[1 - players.indexOf(this)].reset()

						for (let snake of snakes) {
							if (snake.state) {
								if (collide(snake.head, part)) snake.die()
								snake.sense(part)
							}
						}
					}

					if (this.body.length > this.length) this.body.shift()
					if (this.head.x + size < 0) this.head.x = canvas.width
					else if (this.head.x > canvas.width) this.head.x = 0
					else if (this.head.y + size < 0) this.head.y = canvas.height
					else if (this.head.y > canvas.height) this.head.y = 0
				}
			}

			class Font {
				constructor() {
					this.data = {}
					this.source = {
						'!': ' #  #  #     # ',
						'?': '###  # ##    # ',
						'0': '#### ## ## ####',
						'1': '##  #  #  # ###',
						'2': '###  #####  ###',
						'3': '###  # ##  ####',
						'4': '#  #  # ####  #',
						'5': '####  ##   ### ',
						'6': '####  #### ####',
						'7': '###  # #  #  # ',
						'8': '#### ##### ####',
						'9': '#### ####  ####',
						'a': '#### ##### ## #',
						'b': '#### ### # ####',
						'c': '####  #  #  ###',
						'd': '## # ## ## ### ',
						'e': '####  ## #  ###',
						'f': '####  ## #  #  ',
						'g': '####  #  # ####',
						'h': '# ## ##### ## #',
						'i': '### #  #  # ###',
						'j': '  #  #  ## ####',
						'k': '# ## ### # ## #',
						'l': '#  #  #  #  ###',
						'm': '# ##### ## ## #',
						'n': '#### ## ## ## #',
						'o': '#### ## ## ####',
						'p': '#### #####  #  ',
						'q': '#### ####  #  #',
						'r': '#### ### # ## #',
						's': '####  ###  ####',
						't': '### #  #  #  # ',
						'u': '# ## ## ## ####',
						'v': '# ## ## ## # # ',
						'w': '# ## ## ##### #',
						'x': '# ## # # # ## #',
						'y': '# ## #### #  # ',
						'z': '###  # # #  ###',
						'-': '  #    #  ',
						' ': '     ',
						'.': '    #',
						':': ' # # ',
					}
				}

				calculate() {
					for(let index in this.source) {
						let split = this.source[index].match(new RegExp(`.{1,${this.source[index].length / 5}}`, 'g'))
						this.data[index] = []

						for (let row in split) {
							for (let column in split[row]) {
								if (split[row][column] === '#') this.data[index].push({x: column * size, y: row * size})
							}
						}
					}
				}

				find_width(text) {
					let width = 0; for(let char of text) width += font.source[char].length / 5 * size + size
					return width
				}
			}

			class Button {
				constructor(y, text) {
					this.y = y
					this.text = text.toLowerCase()

					let number = random(0, 1)
					this.x = number * canvas.width
					this.speed = (number) ? Math.random() * 1000 : Math.random() * -1000
				}

				update() {
					let text = font.find_width(this.text)
					let width = text + 50, height = size * 5 + 50, y = eval(this.y)
					let hover = mouse.x >= this.x - width / 2 && mouse.x <= this.x + width / 2 && mouse.y >= y - height / 2 && mouse.y <= y + height / 2

					context.fillStyle = hover ? '#666' : '#444'
					context.fillRect(this.x - width / 2, y - height / 2, width, height / 2)
					context.fillStyle = hover ? '#555' : '#333'
					context.fillRect(this.x - width / 2, y, width, height / 2)
					context.fillStyle = '#0f0'

					let x = this.x - text / 2 + size / 2

					for (let char of this.text) {
						for (let square of font.data[char]) context.fillRect(square.x + x, square.y + y - size * 2.5, size, size)
						x += font.find_width(char)
					}

					this.speed += (canvas.width / 2 - this.x) / 10
					this.x += this.speed
					this.speed *= 0.8

					return hover && mouse.press
				}
			}

			function random(a, b) {
				return Math.floor(Math.random() * (b + 1)) + a
			}

			function clear() {
				context.fillStyle = '#222'
				context.fillRect(0, 0, canvas.width, canvas.height)
			}

			function color() {
				return `rgb(${random(0, 255)}, ${random(0, 255)}, ${random(0, 255)})`
			}

			function green() {
				return `rgb( ${random(0, 100)}, ${random(100, 255)}, ${random(0, 100)})`
			}

			function collide(a, b) {
				return (a.x < b.x + size && a.x + size > b.x && a.y < b.y + size && a.y + size > b.y)
			}

			function distance(a, b) {
				return Math.hypot(b.x - a.x, b.y - a.y)
			}

			function resize() {
				canvas.width = innerWidth
				canvas.height = innerHeight

				if (canvas.width > 1500) window.size = 12, window.speed = 5, window.maximum = 30
				else if (canvas.width > 500) window.size = 10, window.speed = 3, window.maximum = 25
				else window.size = 5, window.speed = 1.5, window.maximum = 20

				for (let player of players) player.body = [{x: eval(player.start.x), y: eval(player.start.y)}]

				font.calculate()
			}

			function start() {
				document.body.style.margin = 0
				document.body.style.overflow = 'hidden'
				window.snakes = []
				window.players = []
				window.font = new Font()

				resize()
				window.key = {w: false, s: false, a: false, d: false, up: false, down: false, left: false, right: false}
				window.mouse = {press: false, x: 0, y: 0}
				window.context = canvas.getContext('2d')
				window.rate = {old: 0, total: 0, frequency: 0}
				window.buttons = {
					zero: new Button('canvas.height / 4 * 1', 'no players'),
					one: new Button('canvas.height / 4 * 2', 'one player'),
					two: new Button('canvas.height / 4 * 3', 'two players'),
				}

				addEventListener('mousedown', event => mouse.press = true)
				addEventListener('mouseup', event => mouse.press = false)
				addEventListener('mousemove', event => {mouse.x = event.offsetX || event.layerX, mouse.y = event.offsetY || event.layerY})
				addEventListener('resize', resize)
				addEventListener('keydown', event => key[(event.key.length > 1) ? event.key.slice(5).toLowerCase() : event.key] = true)
				addEventListener('keyup', event => key[(event.key.length > 1) ? event.key.slice(5).toLowerCase() : event.key] = false)

				addEventListener('load', event => {
					if (navigator.userAgent.toLowerCase().match(/mobile/i))
                    	alert("WARNING: This game cannot by played on a mobile device.")
				})

				select()
			}

			function select(time) {
				clear()

				if (buttons.zero.update()) requestAnimationFrame(load)
				else if (buttons.one.update())
					new Player('canvas.width / 2', 'canvas.height / 2', '#99f', 'key.up||key.w', 'key.down||key.s', 'key.left||key.a', 'key.right||key.d'), requestAnimationFrame(load)

				else if (buttons.two.update()) {
					new Player('canvas.width / 3', 'canvas.height / 2', '#99f', 'key.w', 'key.s', 'key.a', 'key.d')
					new Player('canvas.width / 3 * 2', 'canvas.height / 2', '#f99', 'key.up', 'key.down', 'key.left', 'key.right'), requestAnimationFrame(load)
				}

				else requestAnimationFrame(select)
			}

			function load(time) {
				rate.old = time
				for (let index = 0; index < maximum; index ++) new Snake()
				requestAnimationFrame(game)
			}

			function game(time) {
				clear()
				rate.frequency += 1
				if (rate.frequency > 1000) rate.frequency = 0, rate.total = 0

				for (let player of players) player.update()
				for (let snake of snakes) snake.update()
				if (snakes.length < 10 && rate.total / rate.frequency < 16.7) new Snake()
				rate.total += time - rate.old
				rate.old = time

				requestAnimationFrame(game)
			}

			start()
		</script>
	</body>
</html>