<!DOCTYPE html>
<html>
    <head>
        <meta charset = utf-8>
		<title>Code Green</title>

        <style>
            body {
                margin: 0;
                overflow: hidden
            }
        </style>
    </head>

    <body>
        <canvas id = canvas></canvas>

        <script>
            class Text {
                constructor() {
                    this.size = 5

                    this.source = {
                        "M": "## ### # ## # ##   ##   #",
                        "W": "#   ##   ## # ## # # # # ",
                        "0": "#### ## ## ####",
                        "1": "##  #  #  # ###",
                        "2": "###  #####  ###",
                        "3": "###  # ##  ####",
                        "4": "#  #  # ####  #",
                        "5": "####  ##   ### ",
                        "6": "####  #### ####",
                        "7": "###  # #  #  # ",
                        "8": "#### ##### ####",
                        "9": "#### ####  ####",
                        "A": "#### ##### ## #",
                        "B": "#### ### # ####",
                        "C": "####  #  #  ###",
                        "D": "## # ## ## ### ",
                        "E": "####  ## #  ###",
                        "F": "####  ## #  #  ",
                        "G": "####  #  # ####",
                        "H": "# ## ##### ## #",
                        "I": "### #  #  # ###",
                        "J": "  #  #  ## ####",
                        "K": "# ## ### # ## #",
                        "L": "#  #  #  #  ###",
                        "N": "#### ## ## ## #",
                        "O": "#### ## ## ####",
                        "P": "#### #####  #  ",
                        "Q": "#### ####  #  #",
                        "R": "#### ### # ## #",
                        "S": "####  ###  ####",
                        "T": "### #  #  #  # ",
                        "U": "# ## ## ## ####",
                        "V": "# ## ## ## # # ",
                        "X": "# ## # # # ## #",
                        "Y": "# ## #### #  # ",
                        "Z": "###  # # #  ###",
                        "/": "  #  # # #  #  ",
                        ":": " # # "
                    }
                }

                width(text) {
                    let width = 0

                    for (let i = 0; i < text.length; i ++) {
                        if (text[i] == " ") width += 4
                        else width += ~~(this.source[text[i]].length / 5) + 1
                    }

                    return width
                }

                draw(text, pos) {
                    for (let i = 0; i < text.length; i ++) {
                        if (text[i] == " ") {
                            pos.x += this.size * 4
                            continue
                        }

                        const data = this.source[text[i]]
                        const length = ~~(data.length / 5)

                        for (let j in data)
                            if (data[j] == "#")
                                context.fillRect(
                                    ~~(j % length * this.size + pos.x),
                                    ~~(~~(j / length) * this.size + pos.y),
                                    this.size, this.size)

                        pos.x += length * this.size + this.size
                    }
                }
            }

            class Message {
                constructor() {
                    this.messages = {
                        arrows: {
                            message: `Use the ${mobile ? "arrows" : "arrow keys"} to move.`,
                            displayed: false
                        },

                        bombs: {
                            message: `That's a seed bomb! Press ${mobile ? "the square" : "space"} to throw it.`,
                            displayed: false
                        },

                        machines: {
                            message: `Press ${mobile ? "the square" : "space"} to deactivate the enemy machine.`,
                            displayed: false
                        },

                        smoke: {
                            message: "Try to avoid the toxic smoke.",
                            displayed: false
                        }
                    }

                    this.current = 0
                    this.timer = 0
                    this.value = 0
                    this.active = false
                }

                update() {
                    if (this.active) {
                        this.timer --

                        if (this.value < 1) this.value += 0.02
                        if (this.timer < 0) this.active = false
                    }

                    if (this.value > 0) {
                        if (!this.active) this.value -= 0.02

                        context.textAlign = "center"
                        context.font = "20px sans-serif"
                        context.fillStyle = `rgb(255, 255, 255, ${this.value})`
                        context.fillText(this.current, canvas.width / 2, canvas.height / 2 - 100)
                    }
                }

                activate(type) {
                    if (this.messages[type].displayed)
                        return

                    this.messages[type].displayed = true
                    this.current = this.messages[type].message
                    this.active = true
                    this.timer = 500
                }

                deactivate(type) {
                    if (this.current == this.messages[type].message)
                        this.timer = 0
                }
            }

            class Camera {
                constructor() {
                    this.pos = {x: 0, y: 0}
                    this.move = {x: 0, y: 0}
                    this.shake = 0
                }

                visible() {
                    const array = []

                    const side = [
                        Math.floor(this.pos.x - canvas.width / 2 / box),
                        Math.ceil(this.pos.x + canvas.width / 2 / box) + 1,
                        Math.floor(this.pos.y - canvas.height / 2 / box),
                        Math.ceil(this.pos.y + canvas.height / 2 / box) + 1
                    ].map(e => e < 0 ? 0 : e)

                    for (let x = side[0]; x < (side[1] > size.width ? size.width : side[1]); x ++)
                        for (let y = side[2]; y < side[3]; y ++)
                            array.push(index({x, y}))

                    return array
                }

                update() {
                    this.move.x = (player.pos.x - this.pos.x) * this.focus
                    this.move.y = (player.pos.y - this.pos.y) * this.focus
                    this.pos.x += this.move.x
                    this.pos.y += this.move.y

                    if (this.shake) {
                        this.shake --
                        this.pos.x += (Math.random() - 0.5) * this.shift
                        this.pos.y += (Math.random() - 0.5) * this.shift
                    }
                }

                get offset() {
                    return {
                        x: -this.pos.x * box + canvas.width / 2,
                        y: -this.pos.y * box + canvas.height / 2
                    }
                }
            }

            Camera.prototype.focus = 0.08
            Camera.prototype.shift = 0.3

            class Puff {
                constructor(pos, area, color, density) {
                    this.color = color
                    this.particles = []
                    this.time = this.lifetime

                    for (let i = 0; i < density; i ++)
                        this.particles.push({
                            pos: {x: pos.x + (Math.random() - 0.5) * area.x, y: pos.y + (Math.random() - 0.5) * area.y},
                            velocity: -0.03 * Math.random(),
                            size: this.size * (Math.random() / 2 + 0.5)
                        })
                }

                update() {
                    this.time --
                    context.fillStyle = this.color

                    this.particles.forEach(item => {
                        const size = this.time / this.lifetime * item.size * box
                        item.pos.y += item.velocity

                        context.fillRect(
                            item.pos.x * box - size / 2 + camera.offset.x,
                            item.pos.y * box - size / 2 + camera.offset.y,
                            size, size)
                    })
                }

                delete() {return this.time < 0}
            }

            Puff.prototype.size = 0.2
            Puff.prototype.lifetime = 30

            class Spark {
                constructor(pos) {
                    this.particles = []
                    this.time = this.lifetime

                    for (let i = 0; i < 10; i ++)
                        this.particles.push({
                            pos: {x: pos.x + Math.random() - 0.5, y: pos.y + Math.random() - 0.5},
                            velocity: -0.05 * Math.random(),
                            size: this.size * (Math.random() / 2 + 0.5),
                            color: green()
                        })
                }

                update() {
                    this.time --

                    this.particles.forEach(item => {
                        const size = this.time / this.lifetime * item.size * box

                        context.fillStyle = this.time > this.lifetime * 0.9 ? "#fff" : item.color
                        item.pos.y += item.velocity
                        item.pos.x += (Math.random() - 0.5) * 0.05

                        context.fillRect(
                            item.pos.x * box - size / 2 + camera.offset.x,
                            item.pos.y * box - size / 2 + camera.offset.y,
                            size, size)
                    })
                }

                delete() {return this.time < 0}
            }

            Spark.prototype.size = 0.4
            Spark.prototype.lifetime = 50

            class Base {
                collide(base) {
                    return (
                        this.left < base.right &&
                        this.right > base.left &&
                        this.top < base.bottom &&
                        this.bottom > base.top)
                }

                merge(base) {
                    const side = [
                        this.bottom - base.top,
                        this.top - base.bottom,
                        this.right - base.left,
                        this.left - base.right
                    ]

                    const x = side[2] < -side[3] ? side[2] : side[3]
                    const y = side[0] < -side[1] ? side[0] : side[1]

                    if (Math.abs(x) < Math.abs(y)) return {x, y: 0}
                    return {x: 0, y}
                }

                draw() {
                    context.fillRect(
                        ~~((this.pos.x - this.size / 2) * box + camera.offset.x),
                        ~~((this.pos.y - this.size / 2) * box + camera.offset.y),
                        ~~(this.size * box), ~~(this.size * box))
                }

                boundary() {
                    return [
                        {x: Math.floor(this.pos.x), y: Math.floor(this.pos.y)},
                        {x: Math.floor(this.pos.x), y: Math.ceil(this.pos.y)},
                        {x: Math.ceil(this.pos.x), y: Math.floor(this.pos.y)},
                        {x: Math.ceil(this.pos.x), y: Math.ceil(this.pos.y)}
                    ].map(pos => index(pos))
                }

                screen() {
                    const x = this.pos.x * box + camera.offset.x
                    const y = this.pos.y * box + camera.offset.y
                    const size = this.size * box

                    return (
                        x + size / 2 > 0 && x - size / 2 < canvas.width &&
                        y + size / 2 > 0 && y - size / 2 < canvas.width)
                }

                get top() {return this.pos.y - this.size / 2}
                get bottom() {return this.pos.y + this.size / 2}
                get left() {return this.pos.x - this.size / 2}
                get right() {return this.pos.x + this.size / 2}
            }

            class Plant {
                constructor(pos) {
                    this.pos = pos
                    this.stem = {angle: Math.PI, length: 0, split: []}
                    this.stems = 1
                    this.max = random(2, 30)
                }

                update() {
                    const x = this.pos.x * box + camera.offset.x
                    const y = this.pos.y * box + camera.offset.y

                    if (x + box * 2 < 0 || x - box * 2 > canvas.width ||
                        y < 0 || y - box * 4 > canvas.height) return

                    const update = (segment, pos) => {
                        pos.x += Math.sin(segment.angle) * segment.length
                        pos.y += Math.cos(segment.angle) * segment.length

                        const speed = (1 - this.stems / this.max) * Math.random()
                        const x = pos.x * box + camera.offset.x
                        const y = pos.y * box + camera.offset.y
                        const base = main.data[index({x: Math.round(pos.x), y: Math.round(pos.y)})]

                        context.lineTo(x, y)
                        segment.angle += (Math.random() - 0.5) * speed * 0.1

                        if (segment.leaf) {
                            segment.leaf.timer --
                            segment.leaf.size += (segment.leaf.goal - segment.leaf.size) / 10
                            segment.leaf.angle += (Math.random() - 0.5) * speed * 0.5

                            if (segment.leaf.timer < 0 && base instanceof Water) {
                                main.particles.push(new Bubble({x: pos.x, y: pos.y}, Math.PI))
                                segment.leaf.timer = Math.random() * 100
                            }

                            context.save()
                            context.translate(x, y)
                            context.rotate(segment.leaf.angle)
                            context.fillStyle = segment.leaf.color
                            context.fillRect(0, 0, segment.leaf.size * box, segment.leaf.size * box)
                            context.restore()

                            main.particles.forEach((item, index) => {
                                if (item instanceof Smoke &&
                                    pos.x + segment.leaf.size / 2 > item.left &&
                                    pos.x - segment.leaf.size / 2 < item.right &&
                                    pos.y + segment.leaf.size / 2 > item.top &&
                                    pos.y - segment.leaf.size / 2 < item.bottom)
                                        main.particles.splice(index, 1)
                            })
                        }

                        if (segment.flower) {
                            segment.flower.size += (segment.flower.goal - segment.flower.size) / 10
                            segment.flower.angle += (Math.random() - 0.5) * speed * 0.5
                            const size = segment.flower.size * box

                            context.save()
                            context.translate(x, y)
                            context.rotate(segment.flower.angle)
                            context.fillStyle = segment.flower.color

                            for (let i = 0; i < 3; i ++) {
                                context.rotate(Math.PI * 2 / 3)
                                context.fillRect(0, 0, size, size)
                            }

                            context.fillStyle = "#fa0"
                            context.fillRect(-size / 2, -size / 2, size, size)
                            context.restore()
                        }

                        if (segment.split.length)
                            segment.split.forEach(item => {
                                context.moveTo(x, y)
                                update(item, {x: pos.x, y: pos.y})
                            })

                        else if (segment.length > this.length) {
                            if (this.stems < this.max) {
                                for (let i = 0; i < random(1, 2); i ++) {
                                    if (this.stems >= this.max) break

                                    segment.split.push({
                                        angle: segment.angle + Math.random() - 0.5,
                                        length: 0, split: []
                                    })

                                    this.stems ++
                                }

                                if (!random(0, 3))
                                    segment.leaf = {
                                        size: 0, color: green(),
                                        angle: Math.PI * Math.random() * 2,
                                        goal: Math.random() * 0.05 + 0.1,
                                        timer: 0
                                    }

                                else if (!random(0, 20) && !base)
                                    segment.flower = {
                                        size: 0, angle: 0,
                                        color: `rgb(${random(100, 255)}, ${random(100, 255)}, ${random(100, 255)})`,
                                        goal: Math.random() * 0.05 + 0.1
                                    }
                            }
                        }

                        else segment.length += speed * 0.01 + 0.001
                    }

                    context.strokeStyle = "#0f0"
                    context.lineWidth = 2

                    context.beginPath()
                    context.moveTo(x, y)

                    update(this.stem, {x: this.pos.x, y: this.pos.y})
                    context.stroke()
                }
            }

            Plant.prototype.length = 0.3

            class Egg extends Base {
                constructor(pos, speed) {
                    super()
                    this.pos = pos
                    this.speed = speed
                    this.time = this.timer
                }

                update() {
                    this.time --
                    this.speed.y += gravity * this.size
                    this.speed.x *= this.damping
                    this.speed.y *= this.damping
                    this.pos.x += this.speed.x
                    this.pos.y += this.speed.y

                    this.boundary().forEach(base => {
                        if (main.data[base] instanceof Wall && this.collide(main.data[base])) {
                            const merge = this.merge(main.data[base])

                            if (merge.x) {
                                this.pos.x -= merge.x
                                this.speed.x = -Math.sign(merge.x) * Math.abs(this.speed.x) * this.damping
                            }

                            if (merge.y) {
                                this.speed.y = -Math.sign(merge.y) * Math.abs(this.speed.y) * this.damping
                                this.pos.y -= merge.y
                            }
                        }
                    })

                    context.fillStyle = "#ccb"
                    this.draw()

                    if (this.time < 0) {
                        main.particles.push(new Puff(
                            {x: this.pos.x, y: this.pos.y},
                            {x: this.size, y: this.size},
                            "#ddd", 5))

                        const duck = new Duck({x: this.pos.x, y: this.pos.y})
                        main.actors.push(duck)
                        duck.size = this.size
                        duck.velocity = -0.05
                    }
                }

                delete() {return this.time < 0}
            }

            Egg.prototype.size = 0.2
            Egg.prototype.timer = 200
            Egg.prototype.damping = 0.9

            class Bomb extends Base {
                constructor(pos, speed) {
                    super()
                    this.pos = pos
                    this.speed = speed
                    this.particles = []
                    this.time = this.timer
                    this.ground = false
                }

                update() {
                    this.time --
                    this.speed.y += gravity * this.size
                    this.speed.x *= this.damping
                    this.speed.y *= this.damping
                    this.pos.x += this.speed.x
                    this.pos.y += this.speed.y

                    let ground = false

                    const land = merge => {
                        if (merge.x) {
                            this.pos.x -= merge.x
                            this.speed.x = -Math.sign(merge.x) * Math.abs(this.speed.x) * this.damping
                        }

                        if (merge.y) {
                            this.speed.y = -Math.sign(merge.y) * Math.abs(this.speed.y) * this.damping
                            this.pos.y -= merge.y

                            if (merge.y > 0)
                                ground = true
                        }
                    }
                    
                    this.boundary().forEach(base => {
                        if (main.data[base] instanceof Wall && this.collide(main.data[base]))
                            land(this.merge(main.data[base]))
                    })

                    main.actors.forEach(actor => {
                        if (actor instanceof Lift && this.collide(actor)) {
                            land(this.merge(actor))
                            this.pos.y += actor.velocity
                        }
                    })

                    if (!this.ground && ground)
                        main.particles.push(new Puff(
                            {x: this.pos.x, y: this.pos.y},
                            {x: this.size, y: this.size},
                            "#ddd", 5))

                    this.ground = ground

                    if (this.time < 0) {
                        camera.shake = 10

                        const side = [
                            Math.round(this.pos.x - this.spread / 2),
                            Math.round(this.pos.x + this.spread / 2),
                            Math.round(this.pos.y - this.spread / 2),
                            Math.round(this.pos.y + this.spread / 2)
                        ].map(e => e < 0 ? 0 : e)

                        for (let x = side[0]; x < (side[1] > size.width ? size.width : side[1]); x ++)
                            for (let y = side[2]; y < side[3]; y ++) {
                                const base = index({x, y})

                                if (!(main.data[base] instanceof Wall)) {
                                    main.particles.push(new Spark({x, y}))

                                    if (base < size.height * size.width - size.width &&
                                        main.data[base + size.width] instanceof Wall)
                                        for (let i = 0; i < random(1, 3); i ++)
                                            main.actors.push(new Plant({
                                                x: pos(base).x + Math.random() - 0.5,
                                                y: pos(base).y + 0.5
                                            }))
                                }
                            }
                    }

                    context.fillStyle = "#7c0"
                    this.draw()
                }

                delete() {return this.time < 0}
            }

            Bomb.prototype.size = 0.2
            Bomb.prototype.timer = 100
            Bomb.prototype.damping = 0.92
            Bomb.prototype.spread = 4

            class Smoke extends Base {
                constructor(pos, angle, color) {
                    super()
                    this.pos = pos
                    this.time = this.timer * Math.random()
                    this.size = 0.1
                    this.color = color.replace(/[^#]/g, a => a + a)

                    this.speed = {
                        x: Math.sin(angle) * this.limit,
                        y: Math.cos(angle) * this.limit
                    }
                }

                update() {
                    this.size += (0.5 - this.size) / 100

                    this.speed = limit(this.speed, this.limit)
                    this.pos.x += this.speed.x
                    this.pos.y += this.speed.y

                    if (this.collide(player)) {
                        player.health -= 0.001

                        if (player.health < 0)
                            player.die()
                    }

                    this.boundary().forEach(base => {
                        if (main.data[base] instanceof Wall && this.collide(main.data[base])) {
                            const margin = this.merge(main.data[base])
                            this.speed.x -= margin.x / 100
                            this.speed.y -= margin.y / 100
                        }
                    })

                    const shade = Math.floor(this.time / this.timer * 256).toString(16)
                    context.fillStyle = this.color + "0".repeat(2 - shade.length) + shade;

                    context.fillRect(
                        (this.pos.x - this.size / 2) * box + camera.offset.x,
                        (this.pos.y - this.size / 2) * box + camera.offset.y,
                        this.size * box, this.size * box)

                    this.time --
                }

                delete() {return this.time < 0}
            }

            Smoke.prototype.timer = 300
            Smoke.prototype.limit = 0.02

            class Bubble extends Base {
                constructor(pos, angle) {
                    super()
                    this.pos = pos
                    this.time = this.timer * Math.random()
                    this.size = 0

                    this.speed = {
                        x: Math.sin(angle) * this.limit,
                        y: Math.cos(angle) * this.limit
                    }
                }

                update() {
                    this.size += (0.1 - this.size) / 100

                    this.speed = limit(this.speed, this.limit)
                    this.pos.x += this.speed.x
                    this.pos.y += this.speed.y

                    context.lineWidth = 2
                    context.strokeStyle = `rgb(100, 150, 255, ${this.time / this.timer})`

                    context.strokeRect(
                        (this.pos.x - this.size / 2) * box + camera.offset.x,
                        (this.pos.y - this.size / 2) * box + camera.offset.y,
                        this.size * box, this.size * box)

                    this.time --
                }

                delete() {return this.time < 0}
            }

            Bubble.prototype.timer = 200
            Bubble.prototype.limit = 0.01

            class Wall extends Base {
                constructor(index) {
                    super()
                    this.pos = pos(index)
                }

                update() {
                    const tone = shade(this.pos)
                    context.fillStyle = `rgb(${tone}, ${tone}, ${tone})`
                    this.draw()
                }
            }

            Wall.prototype.size = 1
            Wall.prototype.foreground = 1

            class Water extends Base {
                constructor(index) {
                    super()
                    this.pos = pos(index)
                }

                update() {
                    const tone = shade(this.pos)
                    context.fillStyle = `rgb(${tone * 0.4}, ${tone * 0.7}, ${tone}, 0.5)`
                    
                    context.fillRect(
                        (this.pos.x - this.size / 2) * box + camera.offset.x,
                        (this.pos.y - this.size / 2) * box + camera.offset.y,
                        this.size * box, this.size * box)
                }
            }

            Water.prototype.foreground = 1
            Water.prototype.size = 1

            class Lift extends Base {
                constructor(pos) {
                    super()
                    this.pos = pos
                    this.velocity = this.speed
                }

                update() {
                    this.pos.y += this.velocity

                    this.boundary().forEach(base => {
                        if (main.data[base] instanceof Wall && this.collide(main.data[base])) {
                            const margin = this.merge(main.data[base])
                            this.pos.x -= margin.x
                            this.pos.y -= margin.y
                            this.velocity *= -1
                        }
                    })

                    main.actors.forEach(actor => {
                        if (actor instanceof Lift && actor != this && this.collide(actor)) {
                            const margin = this.merge(actor)
                            this.pos.x -= margin.x
                            this.pos.y -= margin.y
                            this.velocity *= -1
                            actor.velocity *= -1
                        }
                    })

                    context.fillStyle = "#ddd"
                    this.draw()
                }
            }

            Lift.prototype.size = 0.7
            Lift.prototype.speed = 0.05

            class Litter extends Base {
                constructor(pos) {
                    super()
                    this.points = new Array(random(6, 10))
                    this.size = Math.random() * 0.2 + 0.3

                    const color = random(0, 100)
                    this.color = `rgb(${color}, ${color}, ${color})`

                    for (let i = 0; i < this.points.length; i ++) {
                        const angle = i / this.points.length * 2 * Math.PI

                        this.points[i] = {
                            x: Math.sin(angle) * (Math.random() * this.size / 2 + this.size / 4),
                            y: Math.cos(angle) * (Math.random() * this.size / 2 + this.size / 4)
                        }
                    }

                    this.pos = {
                        x: pos.x + Math.random() - 0.5,
                        y: pos.y + 0.5 - this.points[0].y
                    }
                }

                update() {
                    const x = this.pos.x * box + camera.offset.x
                    const y = this.pos.y * box + camera.offset.y

                    context.fillStyle = this.color
                    context.beginPath()

                    context.moveTo(
                        x + this.points[this.points.length - 1].x * box,
                        y + this.points[this.points.length - 1].y * box)

                    this.points.forEach(item =>
                        context.lineTo(x + item.x * box, y + item.y * box))

                    context.fill()
                }
            }

            class Ball extends Base {
                constructor(index) {
                    super()
                    this.base = pos(index)
                    this.offset = Math.random() * 2 * Math.PI
                }

                update() {
                    this.offset += this.speed

                    context.fillStyle = "#7c0"
                    context.save()
                    context.translate(this.pos.x * box + camera.offset.x, this.pos.y * box + camera.offset.y)
                    context.rotate(Math.sin(this.offset * 0.9) / 3)

                    context.fillRect(
                        -this.size / 2 * box,
                        -this.size / 2 * box,
                        this.size * box, this.size * box)

                    context.restore()
                }

                get pos() {
                    return {
                        x: this.base.x + Math.cos(this.offset * 0.7) * this.wobble,
                        y: this.base.y + Math.sin(this.offset) * this.wobble
                    }
                }
            }

            Ball.prototype.size = 0.3
            Ball.prototype.speed = 0.2
            Ball.prototype.wobble = 0.05
            Ball.prototype.foreground = 0

            class Machine extends Base {
                constructor(index) {
                    super()
                    this.pos = pos(index)
                    this.time = this.interval
                }

                update() {
                    if (!this.active) return
                    this.time --

                    if (!this.time) {
                        this.smoke()
                        this.time = this.interval
                    }
                }
            }

            Machine.prototype.size = 1
            Machine.prototype.foreground = 0

            class Recycle extends Machine {
                constructor(index) {
                    super(index)
                    this.angle = 0
                    this.active = false
                }

                smoke() {
                    main.particles.push(new Bubble({
                        x: this.pos.x + (Math.random() * 0.4 - 0.2) * this.size,
                        y: this.pos.y - this.size * 0.4
                    }, Math.PI + Math.random() - 0.5))
                }

                update() {
                    super.update()

                    if (this.active)
                        this.angle -= 0.05

                    const tone = shade(this.pos)
                    const size = this.size * box
                    const x = this.pos.x * box + camera.offset.x
                    const y = this.pos.y * box + camera.offset.y

                    context.fillStyle = `rgb(${tone}, ${tone}, ${tone})`
                    context.fillRect(x - size * 0.4, y - size * 0.3, size * 0.8, size * 0.8)

                    context.fillStyle = context.strokeStyle = `rgb(${tone * 0.6}, ${tone * 0.6}, ${tone * 0.6})`
                    context.beginPath()
                    context.moveTo(x - size * 0.3, y - size / 2)
                    context.lineTo(x + size * 0.3, y - size / 2)
                    context.lineTo(x + size * 0.2, y - size * 0.3)
                    context.lineTo(x - size * 0.2, y - size * 0.3)
                    context.fill()

                    context.lineWidth = 3
                    context.save()
                    context.translate(x, y + size * 0.1)
                    context.rotate(this.angle)

                    for (let i = 0; i < 3; i ++) {
                        context.beginPath()
                        context.arc(0, 0, size * 0.2, 0, Math.PI / 3)
                        context.moveTo(size * 0.15, size * 0.05)
                        context.lineTo(size * 0.2, 0)
                        context.lineTo(size * 0.25, size * 0.05)
                        context.stroke()
                        context.rotate(Math.PI * 2 / 3)
                    }

                    context.restore()

                    if (this.active) {
                        context.fillStyle = "#0c0"
                        context.shadowColor = "#0f0"
                        context.shadowBlur = 20
                    }

                    else context.fillStyle = `rgb(${tone * 0.6}, ${tone * 0.6}, ${tone * 0.6})`
                    context.fillRect(x - size * 0.05, y + size * 0.05, size * 0.1, size * 0.1)
                    context.shadowBlur = 0
                }
            }

            Recycle.prototype.interval = 5
            Recycle.prototype.type = 1

            class Chimney extends Machine {
                constructor(index) {
                    super(index)
                    this.active = true
                }

                smoke() {
                    main.particles.push(new Smoke({
                        x: this.pos.x + (Math.random() * 0.8 - 0.4) * this.size,
                        y: this.pos.y - this.size * 0.4
                    }, Math.PI + Math.random() - 0.5, "#000"))
                }

                update() {
                    super.update()

                    const tone = shade(this.pos)
                    const size = this.size * box
                    const x = this.pos.x * box + camera.offset.x
                    const y = this.pos.y * box + camera.offset.y

                    context.fillStyle = `rgb(${tone * 0.6}, ${tone * 0.6}, ${tone * 0.6})`
                    context.fillRect(x - size * 0.4, y - size / 2, size * 0.8, size)

                    context.fillStyle = `rgb(${tone}, ${tone}, ${tone})`
                    context.fillRect(x - size / 2, y - size / 2, size, size * 0.3)

                    if (this.active) {
                        context.fillStyle = "#c00"
                        context.shadowColor = "#f00"
                        context.shadowBlur = 20
                    }

                    else context.fillStyle = `rgb(${tone}, ${tone}, ${tone})`
                    context.fillRect(x - size * 0.2, y + size * 0.2, size * 0.4, size * 0.15)
                    context.shadowBlur = 0
                }
            }

            Chimney.prototype.interval = 2
            Chimney.prototype.type = 0

            class Nuclear extends Machine {
                constructor(index) {
                    super(index)
                    this.active = true
                }

                smoke() {
                    const side = random(0, 1) ? -1 : 1

                    main.particles.push(new Smoke({
                        x: this.pos.x + this.size * 0.4 * side,
                        y: this.pos.y - this.size / 8
                    }, Math.PI / 2 * side + Math.random() - 0.5, "#540"))
                }

                update() {
                    super.update()

                    const tone = shade(this.pos)
                    const size = this.size * box
                    const x = this.pos.x * box + camera.offset.x
                    const y = this.pos.y * box + camera.offset.y

                    context.fillStyle = `rgb(${tone * 0.6}, ${tone * 0.6}, ${tone * 0.6})`
                    context.fillRect(x - size * 0.4, y - size / 2, size * 0.8, size)

                    context.fillStyle = `rgb(${tone}, ${tone}, ${tone})`
                    context.fillRect(x - size / 2, y - size / 4, size * 0.1, size / 4)
                    context.fillRect(x + size * 0.4, y - size / 4, size * 0.1, size / 4)

                    context.beginPath()
                    context.arc(x, y + size / 4, size * 0.2, 0, Math.PI * 2)
                    context.fill()

                    if (this.active) {
                        context.fillStyle = "#c00"
                        context.shadowColor = "#f00"
                        context.shadowBlur = 20
                    }

                    else context.fillStyle = `rgb(${tone}, ${tone}, ${tone})`
                    context.fillRect(x + size * 0.2, y - size * 0.2, size * 0.1, size * 0.1)
                    context.shadowBlur = 0
                }
            }

            Nuclear.prototype.interval = 1
            Nuclear.prototype.type = 0

            class Fish extends Base {
                constructor(pos) {
                    super()
                    this.pos = pos
                    this.look = 1
                    this.size = Math.random() * 0.25 + 0.1
                    this.angle = 0
                    this.color = [random(100, 255), random(100, 255), random(100, 255)]
                    this.timer = 0
                }

                update() {
                    this.timer --
                    this.angle += 0.05 / this.size
                    this.pos.x += (1 - Math.sin(this.angle)) * 0.01 * this.size * this.look

                    if (this.timer < 0) {
                        main.particles.push(new Bubble({
                            x: this.pos.x + this.size / 2 * this.look,
                            y: this.pos.y
                        }, Math.PI))

                        this.timer = Math.random() * 100
                    }

                    const size = this.size * box
                    const eyes = this.eyes * this.size * box
                    const fin = this.fin * this.size * box

                    const x = this.pos.x * box + camera.offset.x
                    const y = this.pos.y * box + camera.offset.y
                    const angle = (Math.sin(this.angle) + 1) / 3 + 0.4
                    const dark = `rgb(${this.color[0] * 0.9}, ${this.color[1] * 0.9}, ${this.color[2] * 0.9})`

                    const left = index({x: Math.round(this.pos.x) - 1, y: Math.round(this.pos.y)})
                    const right = index({x: Math.round(this.pos.x) + 1, y: Math.round(this.pos.y)})

                    if (main.data[left] instanceof Wall && this.look == -1)
                        this.look = 1

                    else if (main.data[right] instanceof Wall && this.look == 1)
                        this.look = -1

                    context.fillStyle = dark
                    context.save()
                    context.translate(x - size / 3 * this.look, y)
                    context.rotate(-angle)
                    context.fillRect(0, -size / 8, -size / 2 * this.look, size / 4)
                    context.rotate(angle * 2)
                    context.fillRect(0, -size / 8, -size / 2 * this.look, size / 4)
                    context.restore()

                    context.fillStyle = `rgb(${this.color[0]}, ${this.color[1]}, ${this.color[2]})`
                    context.fillRect(x - size / 2, y - size / 2, size, size)

                    context.fillStyle = dark
                    context.save()
                    context.translate(x, y)
                    context.rotate(Math.sin(this.angle / 2) / 2)
                    context.fillRect(0, 0, -fin * this.look, fin)
                    context.restore()

                    context.fillStyle = "#000"
                    context.fillRect(
                        x + size / 5 * this.look - eyes / 2,
                        y - size / 5 - eyes / 2,
                        eyes, eyes)
                }
            }

            Fish.prototype.eyes = 0.2
            Fish.prototype.fin = 0.3

            class Creature extends Base {
                constructor(pos) {
                    super()
                    this.pos = pos
                    this.velocity = 0
                    this.angle = 0
                    this.spring = false
                    this.death = {destroyed: false, dead: false}
                    this.direction = {look: 1, speed: 0}
                    this.land = {ground: false, value: 1}
                }

                puff() {
                    main.particles.push(new Puff(
                        {x: this.pos.x, y: this.bottom},
                        {x: this.size, y: 0}, "#555", 5))
                }

                die() {
                    if (this.death.dead) return
                    this.death.dead = true
                    this.angle = 0
                }

                destroy() {
                    if (this.death.destroyed) return

                    main.particles.push(new Puff(
                        this.pos, {x: this.size, y: this.size},
                        this.color, 50))

                    this.death.destroyed = true
                }

                update() {
                    if (this.direction.speed && !this.death.dead) {
                        this.angle += this.wobble
                        this.pos.x += this.speed * this.direction.speed * this.size
                        this.direction.look = this.direction.speed
                    }

                    if (this.death.dead)
                        this.angle -= (Math.PI / 2 * this.direction.look + this.angle) / 5

                    this.velocity += gravity * this.size

                    if (this.velocity > 0.5)
                        this.velocity = 0.5

                    this.pos.y += this.velocity

                    if (this.land.value < 1) this.land.value += 0.13 * this.size
                    const squish = {ground: false, value: 0, lift: false}

                    const land = (merge, base) => {
                        this.pos.x -= merge.x
                        this.pos.y -= merge.y

                        const check = () =>
                            Math.sign(merge.y) != Math.sign(squish.value) &&
                            Math.abs(merge.y) + Math.abs(squish.value) > 0.3 &&
                            this.destroy()

                        if (merge.y) {                            
                            if (squish.value) {
                                if (base instanceof Lift) {
                                    squish.lift = true
                                    check()
                                }

                                if (base instanceof Wall && squish.lift)
                                    check()
                            }

                            this.velocity = 0
                            squish.value = merge.y
                            if (merge.y > 0) squish.ground = true
                        }
                    }

                    this.boundary().forEach(base => {
                        if (main.data[base] && this.collide(main.data[base]) &&
                            main.data[base] instanceof Wall)
                                land(this.merge(main.data[base]), main.data[base])
                    })

                    main.actors.forEach(actor => {
                        if (actor instanceof Lift && this.collide(actor)) {
                            land(this.merge(actor), actor)
                            this.pos.y += actor.velocity
                        }
                    })

                    if (!this.land.ground && squish.ground) {
                        this.puff()
                        this.land.value = 0
                        this.spring = true
                    }

                    this.land.ground = squish.ground
                }
            }

            Creature.prototype.feet = 0.13

            class Duck extends Creature {
                constructor(pos) {
                    super(pos)
                    this.peck = {active: false, value: 0}
                    this.time = 0
                    this.size = Math.random() * 0.2 + 0.15
                    this.bob = 0
                }

                update() {
                    if (this.death.destroyed || !this.screen()) return
                    super.update()
                    this.time --

                    if (!this.death.dead) {
                        let water = false

                        this.boundary().forEach(base => {
                            if (!water && main.data[base] && this.collide(main.data[base]) &&
                                main.data[base] instanceof Water)
                                    water = main.data[base]
                        })

                        if (water) {
                            this.bob += 0.05
                            this.velocity *= 0.8                            
                            this.velocity += (water.top - this.bottom) * gravity * this.size * 5
                            this.pos.y += Math.sin(this.bob) * 0.015

                            if (this.direction.speed && !random(0, 10))
                                this.puff()
                        }

                        if (this.time < 0) {
                            const action = random(0, 10)
                            this.time = Math.random() * 50
                            
                            if (!action) this.direction.speed = 1
                            else if (action == 2) this.direction.speed = -1
                            else if (action <= 7) this.direction.speed = 0

                            else if (action <= 10 && !this.direction.speed && !water)
                                this.peck.active = true
                        }

                        if (this.peck.active) {
                            this.peck.value += 0.3

                            if (this.peck.value > Math.PI) {
                                this.peck.value = 0
                                this.peck.active = false

                                main.actors.forEach((actor, index) => {
                                    if (actor instanceof Litter && this.collide(actor))
                                        this.die()

                                    else if (this.size > Egg.prototype.size && actor instanceof Plant &&
                                        actor.pos.x + 0.1 > this.left && actor.pos.x - 0.1 < this.right &&
                                        actor.pos.y + 0.1 > this.top && actor.pos.y - 0.1 < this.bottom && random(0, 3))
                                            main.particles.push(new Egg(
                                                {x: this.pos.x, y: this.pos.y},
                                                {x: this.direction.look * -0.05, y: -0.05}))
                                })
                            }
                        }

                        main.particles.forEach((item, index) => {
                            if (item instanceof Smoke && this.collide(item))
                                this.die()
                        })
                    }
                    
                    const feet = this.feet * this.size * box
                    const head = this.head * this.size * box
                    const eyes = this.eyes * this.size * box
                    const size = this.size * box
                    const x = this.pos.x * box + camera.offset.x
                    const y = this.pos.y * box + camera.offset.y

                    const foot = (x, y, value) => {
                        const number = this.direction.speed && !this.death.dead ? (Math.cos(this.angle * 1.5) * value + 1) / 2 : 0
                        context.fillStyle = "#f80"

                        context.fillRect(
                            x - feet / 2 + size / 6 * value,
                            y + size / 2 - feet * number,
                            feet, feet)
                    }

                    const body = (x, y) => {
                        context.fillStyle = this.color

                        context.fillRect(
                            x - size / 2, y - size / 2,
                            size, size)

                        context.translate(x, y - size / 2 + head / 2)
                        context.rotate((Math.sin(this.peck.value) + 0.1) * this.direction.look)
                        const position = size * 0.4 * this.direction.look

                        context.fillRect(
                            position - head / 2,
                            -head, head, head)

                        context.fillStyle = "#f80"
                        context.fillRect(
                            position + head * 0.75 * this.direction.look - head / 4,
                            -head / 2, head / 2, head / 4)

                        context.fillStyle = "#000"
                        context.fillRect(
                            position - eyes / 2,
                            -head / 2 - eyes / 2, eyes, this.death.dead ? eyes / 2 : eyes)

                        context.restore()
                    }

                    const rotated = () => {
                        foot(0, 0, 1)
                        foot(0, 0, -1)
                        body(0, 0)
                    }

                    if (this.death.dead) {
                        context.save()
                        context.translate(x, y)
                        context.rotate(this.angle)
                        rotated()
                    }

                    else if (this.direction.speed) {
                        context.save()
                        context.translate(x, y - feet * this.land.value)
                        context.rotate(Math.sin(this.angle) / 10)
                        rotated()
                    }

                    else {
                        const a = x
                        const b = y - feet * this.land.value
                        context.save()

                        foot(a, b, 1)
                        foot(a, b, -1)
                        body(a, b)
                    }
                }
            }

            Duck.prototype.head = 0.7
            Duck.prototype.eyes = 0.2
            Duck.prototype.speed = 0.14
            Duck.prototype.wobble = 0.3
            Duck.prototype.color = "#fc2"

            class Self extends Creature {
                constructor() {
                    super({x: 0, y: 0})
                    this.bombs = 0
                    this.time = 0

                    this.eye = {
                        x: {goal: 1, current: 1},
                        y: {goal: 0, current: 0},
                        blink: {active: false, value: 0},
                        squint: {active: false, value: 1},
                        time: 0
                    }
                }

                jump() {
                    if (this.death.dead || this.death.destroyed) return

                    if (this.land.ground) {
                        this.velocity = -this.force
                        this.puff()
                    }

                    else if (this.spring) {
                        this.velocity = -this.force
                        this.spring = false
                        this.puff()
                    }
                }

                destroy() {
                    if (this.death.destroyed) return
                    camera.shake = 10
                    this.time = this.timer
                    super.destroy()
                }

                die() {
                    if (this.death.dead) return
                    message.activate("smoke")

                    this.time = this.timer
                    this.eye.y.goal = -1
                    super.die()
                }

                reset() {
                    this.death.dead = false
                    this.death.destroyed = false
                    this.health = 1
                }

                space() {
                    let hit = false

                    this.boundary().forEach(base => {
                        if (main.data[base] instanceof Machine &&
                            this.collide(main.data[base])) {
                                main.data[base].active = !main.data[base].active
                                message.deactivate("machines")
                                hit = true
                                check()
                        }
                    })

                    if (!hit && this.bombs) {
                        message.deactivate("bombs")
                        this.bombs --

                        main.particles.push(new Bomb({
                            x: this.pos.x,
                            y: this.pos.y
                        }, {
                            x: this.direction.look * 0.3,
                            y: -0.2
                        }))
                    }
                }

                update() {
                    if (this.time) {
                        this.time --
                        this.time || change(-1)
                    }

                    if (this.health > 1) this.health = 1
                    else if (this.health < 0) this.health = 0
                    if (this.death.destroyed) return

                    if (key.left) this.direction.speed = -1
                    else if (key.right) this.direction.speed = 1
                    else this.direction.speed = 0

                    let water = false

                    this.boundary().forEach(base => {
                        if (main.data[base] && this.collide(main.data[base])) {
                            if (main.data[base] instanceof Ball) {
                                main.particles.push(new Puff(pos(base), {
                                    x: main.data[base].size,
                                    y: main.data[base].size
                                }, "#ddd", 5))

                                main.data[base] = 0
                                this.bombs ++
                                message.activate("bombs")
                            }

                            else if (main.data[base] instanceof Water)
                                water = true

                            else if (main.data[base] instanceof Machine)
                                message.activate("machines")
                        }
                    })

                    if (water) {
                        this.velocity *= 0.9
                        this.velocity -= gravity * this.size * 0.7
                    }

                    main.actors.forEach((actor, index) => {
                        if (actor instanceof Litter && this.collide(actor)) {
                            main.actors.splice(index, 1)

                            main.particles.push(new Puff(actor.pos, {
                                x: actor.size,
                                y: actor.size
                            }, actor.color, 5))

                            check()
                        }
                    })

                    if (this.direction.speed && this.direction.look != this.direction.speed)
                        this.eye.x.goal = this.direction.speed

                    super.update()

                    const move = value => {
                        const d = value.goal - value.current
                        return Math.abs(d) < 0.5 ? value.goal : value.current + Math.sign(d) / 2
                    }

                    this.eye.x.current = move(this.eye.x)
                    this.eye.y.current = move(this.eye.y)
                    
                    if (!this.death.dead) {
                        this.health += 0.0004
                        this.eye.time --

                        if (this.eye.time < 0) {
                            const action = random(0, 10)
                            this.eye.time = Math.random() * 400
                            
                            if (!action) this.eye.squint.active = true
                            else if (action <= 4) this.eye.blink.active = true
                            else if (action <= 7) this.eye.x.goal = Math.random() * 2 - 1
                            else if (action <= 10) this.eye.y.goal = Math.random() * 2 - 1
                        }

                        if (this.eye.blink.active) {
                            this.eye.blink.value += 0.3

                            if (this.eye.blink.value > Math.PI) {
                                this.eye.blink.value = 0
                                this.eye.blink.active = false
                            }
                        }

                        if (this.eye.squint.active) {
                            this.eye.squint.value -= 0.1
                            this.eye.y.goal = 0

                            if (this.eye.squint.value < -10)
                                this.eye.squint.active = false
                        }

                        else if (this.eye.squint.value != 1) {
                            this.eye.squint.value += 0.1
                            this.eye.y.goal = 0

                            if (this.eye.squint.value > 1)
                                this.eye.squint.value = 1
                        }
                    }
                    
                    const feet = this.feet * this.size * box
                    const eyes = this.eyes * this.size * box
                    const pupils = this.pupils * this.size * box
                    const level = this.level * this.size * box
                    const size = this.size * box
                    const x = this.pos.x * box
                    const y = this.pos.y * box

                    const foot = (x, y, value) => {
                        const number = this.direction.speed && !this.death.dead ? (Math.cos(this.angle * 1.5) * value + 1) / 2 : 0
                        context.fillStyle = "#666"

                        context.fillRect(
                            x - feet / 2 - size / 3 * value,
                            y + size / 2 - feet * number,
                            feet, feet)
                    }

                    const body = (x, y) => {
                        context.fillStyle = this.color
                        context.shadowColor = "#fff"
                        context.shadowBlur = 100

                        context.fillRect(
                            x - size / 2, y - size / 2,
                            size, size)

                        context.shadowBlur = 0
                    }

                    const eye = (x, y, value) => {
                        const offset = x + size / 10 * this.direction.look + size / 5 * value
                        const number = this.death.dead ? eyes : this.eye.squint.value * eyes
                        const height = number < pupils ? pupils : number

                        context.fillStyle = "#ddd"
                        context.fillRect(offset - eyes / 2, y + level - height / 2, eyes, height)

                        context.fillStyle = "#000"
                        context.fillRect(
                            offset - pupils / 2 + (eyes - pupils) / 2 * this.eye.x.current,
                            y + level - pupils / 2 + (eyes - pupils) / 2 * this.eye.y.current,
                            pupils, pupils)

                        context.fillStyle = this.color
                        context.fillRect(
                            offset - eyes / 2 - 1,
                            y + level - eyes / 2 - 1, eyes + 2,
                            this.death.dead ? eyes * 0.9 : eyes * Math.sin(this.eye.blink.value))
                    }

                    const rotated = () => {
                        foot(0, 0, 1)
                        foot(0, 0, -1)
                        body(0, 0)
                        eye(0, 0, 1)
                        eye(0, 0, -1)

                        context.restore()
                    }

                    if (this.death.dead) {
                        context.save()
                        context.translate(x + camera.offset.x, y + camera.offset.y)
                        context.rotate(this.angle)
                        rotated()
                    }

                    else if (this.direction.speed) {
                        context.save()
                        context.translate(x + camera.offset.x, y - feet * this.land.value + camera.offset.y)
                        context.rotate(Math.sin(this.angle) / 10)

                        this.eye.time = Math.random() * 500
                        rotated()
                    }

                    else {
                        const a = x + camera.offset.x
                        const b = y - feet * this.land.value + camera.offset.y

                        foot(a, b, 1)
                        foot(a, b, -1)
                        body(a, b)
                        eye(a, b, 1)
                        eye(a, b, -1)
                    }
                }
            }

            Self.prototype.eyes = 0.3
            Self.prototype.pupils = 0.13
            Self.prototype.size = 0.6
            Self.prototype.level = 0.15
            Self.prototype.force = 0.4
            Self.prototype.timer = 80
            Self.prototype.speed = 0.16
            Self.prototype.wobble = 0.4
            Self.prototype.color = "#a80"

            const levels = 10
            const button = 100
            const box = 100
            const gravity = 0.05
            const size = {x: 5, y: 5, width: 0, height: 0}
            const fade = {active: 1, value: 1}
            const key = {left: false, right: false}
            const main = {data: [], actors: [], particles: [], store: {}, level: 0}
            const mobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)
            const begin = {index: 0, timer: 100, play: true}
            const context = canvas.getContext("2d")
            const player = new Self()
            const camera = new Camera()
            const message = new Message()
            const text = new Text()

            function random(a, b) {return ~~(Math.random() * (b - a + 1)) + a}
            function choice(array) {return array[~~(Math.random() * array.length)]}
            function odd(value) {return 2 * Math.floor(value / 2) + 1}
            function index(pos) {return pos.y * size.width + pos.x}
            function change(value) {fade.active || (fade.active = value)}
            function green() {return `rgb(${random(100, 200)}, ${random(200, 255)}, ${random(0, 100)})`}

            function check() {
                let goal = false
                main.actors.forEach(type => type instanceof Litter && (goal = true))

                main.data.forEach(base => {
                    if (base instanceof Machine && (base.type && !base.active) || (!base.type && base.active))
                        goal = true
                })

                goal || change(1)
            }

            function limit(speed, level) {
                const total = Math.abs(speed.x) + Math.abs(speed.y)

                if (total > level) {
                    let divide = level / total
                    speed.x *= divide
                    speed.y *= divide
                }

                return speed
            }

            function level() {
                main.level ++

                size.x += 2
                size.y += 2

                const actors = new Array(size.x * size.y).fill(0)
                const data = new Array(size.x * size.y).fill(1)

                const point = {
                    vertical: 0,
                    lift: false
                }

                size.width = size.x
                size.height = size.y

                if (size.x > 12 && random(0, 2)) {
                    const chamber = {
                        x: odd(random(2, size.x - 8)),
                        y: odd(random(2, size.y - 8))
                    }

                    for (let x = chamber.x; x < chamber.x + 3; x ++)
                        for (let y = chamber.y; y < chamber.y + 3; y ++)
                            data[index({x, y})] = y == chamber.y + 2 ? 6 : 0

                    for (let i = 0; i < random(1, 2); i ++) {
                        const block = {x: 0, y: 0}

                        if (!random(0, 2)) {
                            block.x = odd(random(chamber.x, chamber.x + 2))
                            block.y = chamber.y - 1
                            actors[index(block)] = 1
                        }

                        else {
                            const left = random(0, 1)
                            block.x = left ? chamber.x - 1 : chamber.x + 3
                            block.y = chamber.y
                        }

                        data[index(block)] = 0
                    }
                }

                while (data[point.index] != 1)
                    point.index = odd(random(0, size.y - 4)) * size.x + odd(random(0, size.x - 4))

                data[point.index] = 2
                actors[point.index] = 3

                while (data.includes(2)) {
                    const store = {empty: [], visited: 0}

                    if (point.index >= size.x * 2) {
                        if (data[point.index - size.x * 2] == 1) store.empty.push(0)
                        if (data[point.index - size.x] == 2) store.visited = 0
                    }

                    if (point.index < size.y * size.x - size.x * 2) {
                        if (data[point.index + size.x * 2] == 1) store.empty.push(1)
                        if (data[point.index + size.x] == 2) store.visited = 1
                    }

                    if (point.index % size.x > 1) {
                        if (data[point.index - 2] == 1) store.empty.push(2)
                        if (data[point.index - 1] == 2) store.visited = 2
                    }

                    if (point.index % size.x < size.x - 2) {
                        if (data[point.index + 2] == 1) store.empty.push(3)
                        if (data[point.index + 1] == 2) store.visited = 3
                    }

                    const move = (shift, type) => {
                        data[point.index] = type

                        for (let i = 0; i < 2; i ++) {
                            point.index += !shift ? -size.x : shift == 1 ? size.x : shift == 2 ? -1 : 1
                            data[point.index] = type
                        }
                    }

                    const flat = array => {
                        return (
                            array.includes(2) && array.includes(3) ? random(2, 3) :
                            array.includes(2) ? 2 :
                            array.includes(3) ? 3 :
                            choice(array))
                    }

                    if (store.empty.length > 0) {
                        const shift = point.vertical == 0 ? choice(store.empty) : flat(store.empty)
                        move(shift, 2)

                        if (!shift || shift == 1)
                            point.vertical ++

                        else {
                            point.vertical = 0
                            point.lift = false
                        }

                        if (point.vertical > 1 && !point.lift) {
                            actors[point.index] = 1
                            point.vertical = 0
                            point.lift = true
                        }
                    }

                    else {
                        move(store.visited, 0)
                        point.vertical = 0
                        point.lift = false
                    }
                }

                const create = size => {
                    const numbers = []

                    for (let i = 0; i < size; i ++)
                        numbers[i] = i % 2 ? random(1, 2) : 0

                    return numbers
                }

                const vertical = create(size.y)
                const horizontal = create(size.x)

                const distort = (array, copy) => {
                    const template = []
                    
                    for (let i = 0; i < array.length; i += size.x)
                        template.push(array.slice(i, i + size.x))

                    return template.flatMap((e, i) => {
                        const bit = new Array(vertical[i] + 1).fill(copy ? e : new Array(e.length).fill(0))
                        bit[0] = e
                        return bit
                    }).flat(1).flatMap((e, i) => {
                        const bit = new Array(horizontal[i % size.x] + 1).fill(copy ? e : 0)
                        bit[0] = e
                        return bit
                    })
                }

                size.width += horizontal.reduce((all, item) => all + item)
                size.height += vertical.reduce((all, item) => all + item) + 1

                main.store.data = distort(data, true).map(
                    e => e ? e : main.level && !random(0, 100) ? 2 : 0)

                main.store.actors = distort(actors, false).map(
                    (e, i) => e ? e : !main.store.data[i] && main.level >= 3 && !random(0, 500 / main.level) ? 4 : 0)

                main.store.data.forEach((e, i) => {
                    if (e == 1 && i > size.width && i < size.height * size.width - size.width) {
                        const above = main.store.data[i - size.width]

                        if ((above == 6 || !above) && random(0, 1))
                            main.store.actors[i - size.width] = 2

                        else if (!above) {
                            if (!random(0, 10) && main.level >= 2)
                                main.store.data[i - size.width] = 3

                            else if (!random(0, 20) && main.level >= 4)
                                main.store.data[i - size.width] = 4

                            else if (!random(0, 100 / main.level) && main.level >= 3)
                                main.store.actors[i - size.width] = 5

                            else if (!random(0, 100 / main.level) && main.level >= 5)
                                main.store.data[i - size.width] = 5
                        }
                    }

                    else if (e == 6 && main.level >= 6 && !random(0, 20 / main.level))
                        main.store.actors[i] = 6
                })

                reset()
            }

            function reset() {
                player.reset()
                main.actors.length = 0
                main.particles.length = 0

                main.data = main.store.data.map((e, i) =>
                    e == 1 ? new Wall(i) :
                    e == 2 ? new Ball(i) :
                    e == 3 ? new Chimney(i) :
                    e == 4 ? new Nuclear(i) :
                    e == 5 ? new Recycle(i) :
                    e == 6 ? new Water(i) : 0)

                main.store.actors.forEach((e, i) => {
                    if (e == 1) main.actors.push(new Lift(pos(i)))

                    else if (e == 2)
                        for (let j = 0; j < random(1, 5); j ++)
                            main.actors.push(new Litter(pos(i)))

                    else if (e == 3) {
                        player.pos = pos(i)
                        camera.pos = pos(i)
                    }

                    else if (e == 4)
                        main.actors.push(new Duck(pos(i)))

                    else if (e == 5)
                        main.actors.push(new Plant({
                            x: pos(i).x + Math.random() - 0.5,
                            y: pos(i).y + 0.5
                        }))

                    else if (e == 6) {
                        const fish = new Fish(pos(i))
                        main.actors.push(fish)
                        fish.pos.y += (Math.random() - 0.5) * (1 - fish.size)
                    }
                })
            }

            function shade(pos) {
                const distance = Math.hypot(pos.x - player.pos.x, pos.y - player.pos.y)
                return 100 / (distance < 1 ? 1 : distance) + main.level / levels * 50
            }

            function resize() {
                canvas.width = innerWidth
                canvas.height = innerHeight
                canvas.style.width = innerWidth + "px"
                canvas.style.height = innerHeight + "px"
            }

            function pos(index) {
                return {
                    x: index % size.width,
                    y: ~~(index / size.width)
                }
            }

            function keyboard(code, type) {
                if (code == 37 || code == 65 || code == 81) {
                    message.deactivate("arrows")
                    key.left = type
                }

                else if (code == 39 || code == 68) {
                    message.deactivate("arrows")
                    key.right = type
                }
            }

            function press(pos, index) {
                const x = canvas.width / 5 * index
                const y = canvas.height - button

                return (
                    pos.x > x - button / 2 &&
                    pos.x < x + button / 2 &&
                    pos.y > y - button / 2 &&
                    pos.y < y + button / 2)
            }

            function arrows(pos, type) {
                if (press(pos, 1)) {
                    message.deactivate("arrows")
                    key.left = type
                }

                else if (press(pos, 2)) {
                    message.deactivate("arrows")
                    key.right = type
                }
            }

            function start() {
                addEventListener("resize", resize)
                resize()

                if (mobile) {
                    addEventListener("pointerup", e => arrows(e, false))

                    addEventListener("pointerdown", e => {
                        if (press(e, 4)) {
                            message.deactivate("arrows")
                            player.jump()
                        }

                        else if (press(e, 3)) {
                            if (begin.play) {
                                begin.play = false
                                setTimeout(() => message.activate("arrows"), 1000)
                                loop()
                            }
                            
                            else player.space()
                        }

                        else arrows(e, true)
                    })
                }

                addEventListener("keyup", e => keyboard(e.keyCode, false))

                addEventListener("keydown", e => {
                    if (e.repeat) return

                    if (e.keyCode == 38 || e.keyCode == 87 || e.keyCode == 90) {
                        message.deactivate("arrows")
                        player.jump()
                    }

                    else if (e.keyCode == 82) player.destroy()
                    else if (e.keyCode == 32) {
                        if (begin.play) {
                            begin.play = false
                            setTimeout(() => message.activate("arrows"), 1000)
                            loop()
                        }
                        
                        else player.space()
                    }

                    else keyboard(e.keyCode, true)
                })

                intro()
            }

            function intro() {
                requestAnimationFrame(intro)

                const start = "CODE "
                const end = "GREEN"
                text.size = 8

                context.fillStyle = "#000"
                context.fillRect(0, 0, canvas.width, canvas.height)
                context.fillStyle = "#888"

                text.draw(start.substring(0, begin.index), {
                    x: canvas.width / 2 - text.width(start + end) / 2 * text.size,
                    y: canvas.height / 2 - 7 * text.size
                })

                if (begin.index > start.length + end.length + 5) {
                    const message = (mobile ? "TAP" : "PRESS SPACE") + " TO START"
                    context.fillStyle = "#888"
                    text.size = 3

                    text.draw(message, {
                        x: canvas.width / 2 - text.width(message) / 2 * text.size,
                        y: canvas.height / 2
                    })

                    text.size = 8
                    context.fillStyle = "#282"
                }

                text.draw(end.substring(0, begin.index - start.length), {
                    x: canvas.width / 2 - (text.width(start + end) / 2 - text.width(start)) * text.size,
                    y: canvas.height / 2 - 7 * text.size
                })

                begin.timer --

                if (begin.timer < 0) {
                    begin.index ++
                    begin.timer = random(5, 20)
                }
            }

            function loop() {
                requestAnimationFrame(loop)
                camera.update()

                const shade = main.level / levels * 255
                const visible = camera.visible()
                
                context.fillStyle = `rgb(${shade * 0.8}, ${shade * 0.9}, ${shade})`
                context.fillRect(0, 0, canvas.width, canvas.height)

                main.particles.forEach((particle, index) => particle.delete() && main.particles.splice(index, 1))
                main.particles.forEach(particle => particle.update())
                visible.forEach(base => main.data[base] && !main.data[base].foreground && main.data[base].update())

                player.update()
                main.actors.forEach(actor => actor.update())
                visible.forEach(base => main.data[base] && main.data[base].foreground && main.data[base].update())

                const bombs = "SEED BOMBS: " + player.bombs
                const width = text.width(bombs)
                text.size = 5

                context.fillStyle = "#fff"
                text.draw(`LEVEL: ${main.level}/${levels}`, {x: text.size, y: text.size})
                text.draw(bombs, {x: canvas.width - text.size - width * text.size, y: text.size})

                context.lineWidth = 5
                context.strokeStyle = context.fillStyle = player.health < 0.2 ? "#f00" : "#fff"
                context.strokeRect(canvas.width / 2 - 200, text.size, 400, text.size * 5)
                context.fillRect(canvas.width / 2 - 200, text.size, player.health * 400, text.size * 5)

                if (mobile) {
                    const x = canvas.width / 5
                    const y = canvas.height - button

                    context.fillStyle = "#fff"
                    context.beginPath()

                    context.moveTo(x + button / 4, y - button / 2)
                    context.lineTo(x - button / 4, y)
                    context.lineTo(x + button / 4, y + button / 2)

                    context.moveTo(x * 2 - button / 4, y - button / 2)
                    context.lineTo(x * 2 + button / 4, y)
                    context.lineTo(x * 2 - button / 4, y + button / 2)

                    context.moveTo(x * 4 - button / 2, y + button / 4)
                    context.lineTo(x * 4, y - button / 4)
                    context.lineTo(x * 4 + button / 2, y + button / 4)

                    context.lineWidth = 20
                    context.stroke()

                    context.strokeRect(
                        x * 3 - button * 0.4,
                        y - button * 0.4,
                        button * 0.8, button * 0.8)
                }

                message.update()

                if (fade.active) {
                    fade.value += 0.02

                    if (fade.value > 1) {
                        fade.active == 1 ? level() : reset()
                        fade.active = 0
                    }
                }

                if (fade.value > 0) {
                    if (!fade.active) fade.value -= 0.02
                    context.fillStyle = `rgb(0, 0, 0, ${fade.value})`
                    context.fillRect(0, 0, canvas.width, canvas.height)
                }
            }

            start()
        </script>
    </body>
</html>